{
  "id": "019c6213-4c9d-7142-ac7d-348c19030d50",
  "title": "Copilot",
  "messages": [
    {
      "role": "user",
      "content": "/insight",
      "timestamp": "2026-02-15T16:12:50.875Z"
    },
    {
      "role": "assistant",
      "content": "# Project Design Insight Document\n\n## 1. Vision & Purpose\n\n**SpecBook** is a comprehensive specification management system that bridges the gap between requirements documentation and code implementation. Its core mission is to solve the perennial problem of **specification drift** — where documentation becomes disconnected from actual code over time.\n\nThe system enables teams to:\n- Create hierarchical, structured specifications that mirror software architecture\n- Maintain a living glossary of domain terminology\n- Leverage AI to automatically analyze code-to-spec alignment\n- Collaborate through conversational requirements exploration\n- Track implementation status across the development lifecycle\n\n**Target Users**: Product managers, business analysts, software architects, and development teams who need to maintain coherent specifications throughout the software development process.\n\n## 2. Core Abstractions & Domain Model\n\nThe system is built around several fundamental concepts that form a cohesive domain model:\n\n```mermaid\nclassDiagram\n    class ObjectTreeNode {\n        +string id\n        +string title\n        +string? parentId\n        +boolean completed\n        +boolean isState\n        +boolean hasContent\n        +ObjectTreeNode[] children\n    }\n    \n    class ObjectDetail {\n        +string id\n        +string title\n        +string content\n        +ObjectAction[] actions\n        +RelatedFile[] impls\n        +RelatedFile[] tests\n        +string createdAt\n        +string updatedAt\n    }\n    \n    class GlossaryTerm {\n        +string id\n        +string name\n        +string[] aliases\n        +string description\n        +string? category\n    }\n    \n    class KnowledgeEntry {\n        +string id\n        +string title\n        +string content\n        +string[] tags\n    }\n    \n    class ChatSession {\n        +string id\n        +string title\n        +ChatMessage[] messages\n    }\n    \n    class AnalysisResult {\n        +ObjectMapping[] mappings\n        +TokenUsage tokenUsage\n        +string directoryTree\n    }\n    \n    ObjectTreeNode ||--o{ ObjectTreeNode : \"parent-child\"\n    ObjectTreeNode ||--|| ObjectDetail : \"detailed view\"\n    ObjectDetail ||--o{ RelatedFile : \"implementation mapping\"\n    AnalysisResult ||--o{ ObjectMapping : \"AI analysis\"\n```\n\n**Key Relationships**:\n- **Hierarchical Specifications**: Objects form a tree structure representing system decomposition\n- **Traceability**: Each spec object can be mapped to implementation files and tests\n- **Knowledge Integration**: Glossary terms and knowledge entries provide contextual understanding\n- **AI-Driven Analysis**: Automated mapping between specifications and code artifacts\n\n## 3. Architectural Philosophy\n\nSpecBook follows a **multi-platform, domain-driven architecture** with clear separation of concerns:\n\n```mermaid\ngraph TD\n    A[Desktop App] --> B[Shared Domain]\n    C[VS Code Extension] --> B\n    D[Web App] --> B\n    E[AI Package] --> B\n    \n    B --> F[File System Storage]\n    E --> G[Anthropic API]\n    \n    subgraph \"Desktop Architecture\"\n        H[Renderer/React] --> I[IPC Layer]\n        I --> J[Main Process]\n        J --> K[Infrastructure Layer]\n        K --> L[Domain Services]\n    end\n    \n    subgraph \"Storage Strategy\"\n        M[.spec/specs.json] --> N[Index Files]\n        O[.spec/specs/*.md] --> P[Content Files]\n        Q[.spec/glossary.json] --> R[Domain Data]\n    end\n```\n\n**Architectural Decisions**:\n\n| Decision | Choice | Rationale |\n|----------|--------|----------|\n| Storage | File-based JSON + Markdown | Version control friendly, human readable, no database dependencies |\n| Multi-platform | Shared domain package | Code reuse across desktop, web, and VS Code extension |\n| AI Integration | Anthropic Claude | Advanced reasoning capabilities for semantic code analysis |\n| Desktop Framework | Electron + React | Cross-platform desktop with rich UI capabilities |\n| State Management | React hooks + IPC | Simple, predictable state flow without complex state libraries |\n| File Organization | Hierarchical .spec directory | Clear separation of concerns, easy backup/sync |\n\n**Key Patterns**:\n- **Hexagonal Architecture**: Clear boundaries between domain, application, and infrastructure layers\n- **Event-Driven IPC**: Electron's IPC system provides clean separation between main and renderer processes\n- **Repository Pattern**: File-based storage abstracted behind clean interfaces\n- **Adapter Pattern**: AI providers abstracted to allow future extensibility\n\n## 4. Key Workflows\n\n### Workflow 1: Specification Creation & Management\n**Trigger**: User creates/edits specifications → **Process**: Validation, ID generation, file persistence → **Outcome**: Hierarchical spec tree with markdown content\n\n```mermaid\nsequenceDiagram\n    participant U as User\n    participant R as Renderer\n    participant M as Main Process\n    participant S as SpecStore\n    participant F as File System\n    \n    U->>R: Create/Edit Spec\n    R->>M: IPC: ADD_OBJECT/UPDATE_OBJECT\n    M->>M: Validate title, generate ID\n    M->>S: addObject/updateObject\n    S->>F: Write specs.json + content.md\n    F-->>S: Confirm\n    S-->>M: Return ObjectDetail\n    M-->>R: IPC Response\n    R-->>U: Update UI\n```\n\n### Workflow 2: AI-Powered Code Analysis\n**Trigger**: User requests analysis → **Process**: Tree scanning, prompt building, AI inference, result mapping → **Outcome**: Implementation status mapping\n\n```mermaid\nsequenceDiagram\n    participant U as User\n    participant R as Renderer\n    participant M as Main Process\n    participant AI as AI Service\n    participant A as Anthropic API\n    participant FS as File Scanner\n    \n    U->>R: Request Analysis\n    R->>M: IPC: AI_ANALYZE\n    M->>FS: scanProjectTree()\n    FS-->>M: Directory structure\n    M->>AI: analyzeObjectTree()\n    AI->>AI: buildSystemPrompt + buildUserPrompt\n    AI->>A: callAnthropic()\n    A-->>AI: Analysis results\n    AI-->>M: AnalysisResult\n    M->>M: appendTokenUsage()\n    M-->>R: IPC Response\n    R-->>U: Display mappings\n```\n\n### Workflow 3: Conversational Requirements Exploration\n**Trigger**: User sends chat message → **Process**: Context building, AI conversation, knowledge extraction → **Outcome**: Refined understanding with glossary suggestions\n\n```mermaid\nsequenceDiagram\n    participant U as User\n    participant C as Chat UI\n    participant M as Main Process\n    participant AI as AI Service\n    participant CS as ChatStore\n    \n    U->>C: Send message\n    C->>M: IPC: CHAT_SEND_MESSAGE\n    M->>CS: appendMessage (user)\n    M->>AI: callChat with history\n    AI-->>M: Assistant response\n    M->>CS: appendMessage (assistant)\n    M-->>C: Return assistant message\n    C-->>U: Display response + glossary suggestions\n```\n\n## 5. Data Flow & State Management\n\n**Data flows through three primary channels**:\n\n1. **Specification Data**: JSON index files → Markdown content files → React state via IPC\n2. **AI Analysis**: Project files → Prompt building → API calls → Result persistence → UI updates\n3. **Domain Knowledge**: Glossary/Knowledge JSON → Contextual UI integration\n\n**State Persistence Strategy**:\n- **Specifications**: Hybrid approach with JSON metadata and Markdown content files\n- **Configuration**: Application-level JSON config files\n- **Chat Sessions**: Individual JSON files per session\n- **Analysis Results**: Embedded in specification objects as related files\n\n**Key Data Transformations**:\n- Object tree flattening/reconstruction for hierarchical display\n- Markdown parsing for rich content rendering\n- AI response parsing from JSON to typed domain objects\n- File path resolution between relative and absolute paths\n\n## 6. Extension Points & Design Patterns\n\n**Extensibility Mechanisms**:\n\n1. **AI Provider Abstraction**: The `anthropicAdapter.ts` can be extended to support other LLM providers\n2. **Storage Backend**: File-based storage can be replaced with database backends\n3. **Platform Packages**: Shared domain enables easy addition of new client platforms\n4. **Command System**: Chat slash commands provide extensible functionality\n5. **File Type Support**: Scanner can be extended for additional file types and languages\n\n**Key Design Patterns**:\n- **Strategy Pattern**: AI provider selection and configuration\n- **Observer Pattern**: React hooks for state synchronization\n- **Factory Pattern**: ID generation and object creation\n- **Template Method**: Prompt building with customizable components\n- **Adapter Pattern**: File system abstraction and IPC communication\n\n**Growth Seams**:\n- Plugin architecture for custom analysis rules\n- Webhook integration for external tool synchronization\n- Real-time collaboration through WebSocket integration\n- Advanced visualization through diagram generation\n- Integration APIs for CI/CD pipeline integration\n\n## 7. Technical Decisions\n\n| Decision | Choice | Rationale |\n|----------|--------|----------|\n| **Monorepo Structure** | pnpm workspaces | Shared code reuse, simplified dependency management |\n| **Type System** | TypeScript throughout | Type safety across all packages, better developer experience |\n| **UI Framework** | Ant Design + React | Professional UI components, consistent design system |\n| **Markdown Rendering** | react-markdown + remark-gfm | Rich content support with GitHub-flavored extensions |\n| **Diagram Support** | Mermaid.js | Code-as-diagrams approach, version control friendly |\n| **File Watching** | Manual refresh | Simplicity over complexity, explicit user control |\n| **Drag & Drop** | @dnd-kit | Modern, accessible drag-and-drop for tree manipulation |\n| **Build System** | electron-vite | Fast development builds, optimized production bundles |\n| **Testing Strategy** | Domain validation only | Focus on business logic validation over UI testing |\n| **Internationalization** | User language detection | Responsive to user's language preferences |\n\nThe architecture demonstrates a sophisticated understanding of modern software design principles, emphasizing maintainability, extensibility, and user experience while solving the complex problem of keeping specifications aligned with evolving codebases.",
      "timestamp": "2026-02-15T16:13:37.669Z"
    }
  ],
  "createdAt": "2026-02-15T16:12:37.917Z",
  "updatedAt": "2026-02-15T16:13:37.669Z"
}
